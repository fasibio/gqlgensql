// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"

	"github.com/fasibio/gqlgensql/graph/db"
	"github.com/fasibio/gqlgensql/graph/generated"
	"github.com/fasibio/gqlgensql/graph/model"
	"github.com/fasibio/gqlgensql/plugin/gqlgensql/runtimehelper"
	"gorm.io/gorm/clause"
)

// GetCat is the resolver for the getCat field.
func (r *queryResolver) GetCat(ctx context.Context, id int) (*model.Cat, error) {
	v, okHook := r.Sql.Hooks["GetCat"].(db.GqlGenSqlHookGet[model.Cat])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Cat"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Cat
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCat is the resolver for the queryCat field.
func (r *queryResolver) QueryCat(ctx context.Context, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int) (*model.CatQueryResult, error) {
	v, okHook := r.Sql.Hooks["QueryCat"].(db.GqlGenSqlHookQuery[model.Cat, model.CatFiltersInput, model.CatOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Cat
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CatQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCatPayload() generated.AddCatPayloadResolver {
	return &catPayloadResolver[*model.AddCatPayload]{r}
}
func (r *Resolver) DeleteCatPayload() generated.DeleteCatPayloadResolver {
	return &catPayloadResolver[*model.DeleteCatPayload]{r}
}
func (r *Resolver) UpdateCatPayload() generated.UpdateCatPayloadResolver {
	return &catPayloadResolver[*model.UpdateCatPayload]{r}
}

type catPayload interface {
	*model.AddCatPayload | *model.DeleteCatPayload | *model.UpdateCatPayload
}

type catPayloadResolver[T catPayload] struct {
	*Resolver
}

func (r *catPayloadResolver[T]) Cat(ctx context.Context, obj T, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int) (*model.CatQueryResult, error) {
	return r.Query().QueryCat(ctx, filter, order, first, offset)
}

// AddCat is the resolver for the addCat field.
func (r *mutationResolver) AddCat(ctx context.Context, input []*model.CatInput) (*model.AddCatPayload, error) {
	v, okHook := r.Sql.Hooks["AddCat"].(db.GqlGenSqlHookAdd[model.Cat, model.CatInput, model.AddCatPayload])
	res := &model.AddCatPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Cat, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCat is the resolver for the updateCat field.
func (r *mutationResolver) UpdateCat(ctx context.Context, input model.UpdateCatInput) (*model.UpdateCatPayload, error) {
	v, okHook := r.Sql.Hooks["UpdateCat"].(db.GqlGenSqlHookUpdate[model.Cat, model.UpdateCatInput, model.UpdateCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	obj := model.Cat{}
	db = db.Model(&obj).Where(sql, arguments...)
	u := input.Set.MergeToType()
	update := &u
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(*update)
	res := &model.UpdateCatPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCat is the resolver for the deleteCat field.
func (r *mutationResolver) DeleteCat(ctx context.Context, filter model.CatFiltersInput) (*model.DeleteCatPayload, error) {
	v, okHook := r.Sql.Hooks["DeleteCat"].(db.GqlGenSqlHookDelete[model.Cat, model.CatFiltersInput, model.DeleteCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
	obj := model.Cat{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCatPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetCompany is the resolver for the getCompany field.
func (r *queryResolver) GetCompany(ctx context.Context, id int) (*model.Company, error) {
	v, okHook := r.Sql.Hooks["GetCompany"].(db.GqlGenSqlHookGet[model.Company])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Company"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Company
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCompany is the resolver for the queryCompany field.
func (r *queryResolver) QueryCompany(ctx context.Context, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int) (*model.CompanyQueryResult, error) {
	v, okHook := r.Sql.Hooks["QueryCompany"].(db.GqlGenSqlHookQuery[model.Company, model.CompanyFiltersInput, model.CompanyOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Company
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CompanyQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCompanyPayload() generated.AddCompanyPayloadResolver {
	return &companyPayloadResolver[*model.AddCompanyPayload]{r}
}
func (r *Resolver) DeleteCompanyPayload() generated.DeleteCompanyPayloadResolver {
	return &companyPayloadResolver[*model.DeleteCompanyPayload]{r}
}
func (r *Resolver) UpdateCompanyPayload() generated.UpdateCompanyPayloadResolver {
	return &companyPayloadResolver[*model.UpdateCompanyPayload]{r}
}

type companyPayload interface {
	*model.AddCompanyPayload | *model.DeleteCompanyPayload | *model.UpdateCompanyPayload
}

type companyPayloadResolver[T companyPayload] struct {
	*Resolver
}

func (r *companyPayloadResolver[T]) Company(ctx context.Context, obj T, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int) (*model.CompanyQueryResult, error) {
	return r.Query().QueryCompany(ctx, filter, order, first, offset)
}

// AddCompany is the resolver for the addCompany field.
func (r *mutationResolver) AddCompany(ctx context.Context, input []*model.CompanyInput) (*model.AddCompanyPayload, error) {
	v, okHook := r.Sql.Hooks["AddCompany"].(db.GqlGenSqlHookAdd[model.Company, model.CompanyInput, model.AddCompanyPayload])
	res := &model.AddCompanyPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Company, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.UpdateCompanyPayload, error) {
	v, okHook := r.Sql.Hooks["UpdateCompany"].(db.GqlGenSqlHookUpdate[model.Company, model.UpdateCompanyInput, model.UpdateCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	obj := model.Company{}
	db = db.Model(&obj).Where(sql, arguments...)
	u := input.Set.MergeToType()
	update := &u
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(*update)
	res := &model.UpdateCompanyPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, filter model.CompanyFiltersInput) (*model.DeleteCompanyPayload, error) {
	v, okHook := r.Sql.Hooks["DeleteCompany"].(db.GqlGenSqlHookDelete[model.Company, model.CompanyFiltersInput, model.DeleteCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
	obj := model.Company{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCompanyPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetCreditCard is the resolver for the getCreditCard field.
func (r *queryResolver) GetCreditCard(ctx context.Context, id int) (*model.CreditCard, error) {
	v, okHook := r.Sql.Hooks["GetCreditCard"].(db.GqlGenSqlHookGet[model.CreditCard])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "CreditCard"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.CreditCard
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCreditCard is the resolver for the queryCreditCard field.
func (r *queryResolver) QueryCreditCard(ctx context.Context, filter *model.CreditCardFiltersInput, order *model.CreditCardOrder, first *int, offset *int) (*model.CreditCardQueryResult, error) {
	v, okHook := r.Sql.Hooks["QueryCreditCard"].(db.GqlGenSqlHookQuery[model.CreditCard, model.CreditCardFiltersInput, model.CreditCardOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.CreditCard
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("CreditCard")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CreditCardQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCreditCardPayload() generated.AddCreditCardPayloadResolver {
	return &creditCardPayloadResolver[*model.AddCreditCardPayload]{r}
}
func (r *Resolver) DeleteCreditCardPayload() generated.DeleteCreditCardPayloadResolver {
	return &creditCardPayloadResolver[*model.DeleteCreditCardPayload]{r}
}
func (r *Resolver) UpdateCreditCardPayload() generated.UpdateCreditCardPayloadResolver {
	return &creditCardPayloadResolver[*model.UpdateCreditCardPayload]{r}
}

type creditCardPayload interface {
	*model.AddCreditCardPayload | *model.DeleteCreditCardPayload | *model.UpdateCreditCardPayload
}

type creditCardPayloadResolver[T creditCardPayload] struct {
	*Resolver
}

func (r *creditCardPayloadResolver[T]) CreditCard(ctx context.Context, obj T, filter *model.CreditCardFiltersInput, order *model.CreditCardOrder, first *int, offset *int) (*model.CreditCardQueryResult, error) {
	return r.Query().QueryCreditCard(ctx, filter, order, first, offset)
}

// AddCreditCard is the resolver for the addCreditCard field.
func (r *mutationResolver) AddCreditCard(ctx context.Context, input []*model.CreditCardInput) (*model.AddCreditCardPayload, error) {
	v, okHook := r.Sql.Hooks["AddCreditCard"].(db.GqlGenSqlHookAdd[model.CreditCard, model.CreditCardInput, model.AddCreditCardPayload])
	res := &model.AddCreditCardPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.CreditCard, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCreditCard is the resolver for the updateCreditCard field.
func (r *mutationResolver) UpdateCreditCard(ctx context.Context, input model.UpdateCreditCardInput) (*model.UpdateCreditCardPayload, error) {
	v, okHook := r.Sql.Hooks["UpdateCreditCard"].(db.GqlGenSqlHookUpdate[model.CreditCard, model.UpdateCreditCardInput, model.UpdateCreditCardPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("CreditCard")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	obj := model.CreditCard{}
	db = db.Model(&obj).Where(sql, arguments...)
	u := input.Set.MergeToType()
	update := &u
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(*update)
	res := &model.UpdateCreditCardPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCreditCard is the resolver for the deleteCreditCard field.
func (r *mutationResolver) DeleteCreditCard(ctx context.Context, filter model.CreditCardFiltersInput) (*model.DeleteCreditCardPayload, error) {
	v, okHook := r.Sql.Hooks["DeleteCreditCard"].(db.GqlGenSqlHookDelete[model.CreditCard, model.CreditCardFiltersInput, model.DeleteCreditCardPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("CreditCard")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
	obj := model.CreditCard{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCreditCardPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetTodo is the resolver for the getTodo field.
func (r *queryResolver) GetTodo(ctx context.Context, id int) (*model.Todo, error) {
	v, okHook := r.Sql.Hooks["GetTodo"].(db.GqlGenSqlHookGet[model.Todo])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Todo"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Todo
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryTodo is the resolver for the queryTodo field.
func (r *queryResolver) QueryTodo(ctx context.Context, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	v, okHook := r.Sql.Hooks["QueryTodo"].(db.GqlGenSqlHookQuery[model.Todo, model.TodoFiltersInput, model.TodoOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Todo
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.TodoQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddTodoPayload() generated.AddTodoPayloadResolver {
	return &todoPayloadResolver[*model.AddTodoPayload]{r}
}
func (r *Resolver) DeleteTodoPayload() generated.DeleteTodoPayloadResolver {
	return &todoPayloadResolver[*model.DeleteTodoPayload]{r}
}
func (r *Resolver) UpdateTodoPayload() generated.UpdateTodoPayloadResolver {
	return &todoPayloadResolver[*model.UpdateTodoPayload]{r}
}

type todoPayload interface {
	*model.AddTodoPayload | *model.DeleteTodoPayload | *model.UpdateTodoPayload
}

type todoPayloadResolver[T todoPayload] struct {
	*Resolver
}

func (r *todoPayloadResolver[T]) Todo(ctx context.Context, obj T, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	return r.Query().QueryTodo(ctx, filter, order, first, offset)
}
func (r *mutationResolver) AddUser2Todos(ctx context.Context, input model.UserRef2TodosInput) (*model.UpdateTodoPayload, error) {
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	db := r.Sql.Db.Model(&model.Todo{}).Where(sql, arguments...)
	var res []*model.Todo
	db.Find(&res)
	type UserTodos struct {
		TodoID int
		UserID int
	}
	resIds := make([]map[string]interface{}, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			tmp := make(map[string]interface{})
			tmp["TodoID"] = v.ID
			tmp["UserID"] = v1
			resIds = append(resIds, tmp)
		}
	}
	d := r.Sql.Db.Model(&UserTodos{}).Create(resIds)
	return &model.UpdateTodoPayload{
		Count: int(d.RowsAffected),
	}, d.Error
}

// AddTodo is the resolver for the addTodo field.
func (r *mutationResolver) AddTodo(ctx context.Context, input []*model.TodoInput) (*model.AddTodoPayload, error) {
	v, okHook := r.Sql.Hooks["AddTodo"].(db.GqlGenSqlHookAdd[model.Todo, model.TodoInput, model.AddTodoPayload])
	res := &model.AddTodoPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Todo, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks["UpdateTodo"].(db.GqlGenSqlHookUpdate[model.Todo, model.UpdateTodoInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	obj := model.Todo{}
	db = db.Model(&obj).Where(sql, arguments...)
	u := input.Set.MergeToType()
	update := &u
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(*update)
	res := &model.UpdateTodoPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, filter model.TodoFiltersInput) (*model.DeleteTodoPayload, error) {
	v, okHook := r.Sql.Hooks["DeleteTodo"].(db.GqlGenSqlHookDelete[model.Todo, model.TodoFiltersInput, model.DeleteTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
	obj := model.Todo{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteTodoPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id int) (*model.User, error) {
	v, okHook := r.Sql.Hooks["GetUser"].(db.GqlGenSqlHookGet[model.User])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "User"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.User
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUser is the resolver for the queryUser field.
func (r *queryResolver) QueryUser(ctx context.Context, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	v, okHook := r.Sql.Hooks["QueryUser"].(db.GqlGenSqlHookQuery[model.User, model.UserFiltersInput, model.UserOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.User
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UserQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUserPayload() generated.AddUserPayloadResolver {
	return &userPayloadResolver[*model.AddUserPayload]{r}
}
func (r *Resolver) DeleteUserPayload() generated.DeleteUserPayloadResolver {
	return &userPayloadResolver[*model.DeleteUserPayload]{r}
}
func (r *Resolver) UpdateUserPayload() generated.UpdateUserPayloadResolver {
	return &userPayloadResolver[*model.UpdateUserPayload]{r}
}

type userPayload interface {
	*model.AddUserPayload | *model.DeleteUserPayload | *model.UpdateUserPayload
}

type userPayloadResolver[T userPayload] struct {
	*Resolver
}

func (r *userPayloadResolver[T]) User(ctx context.Context, obj T, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	return r.Query().QueryUser(ctx, filter, order, first, offset)
}
func (r *mutationResolver) AddTodo2Users(ctx context.Context, input model.TodoRef2UsersInput) (*model.UpdateUserPayload, error) {
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	db := r.Sql.Db.Model(&model.User{}).Where(sql, arguments...)
	var res []*model.User
	db.Find(&res)
	type UserTodos struct {
		UserID int
		TodoID int
	}
	resIds := make([]map[string]interface{}, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			tmp := make(map[string]interface{})
			tmp["UserID"] = v.ID
			tmp["TodoID"] = v1
			resIds = append(resIds, tmp)
		}
	}
	d := r.Sql.Db.Model(&UserTodos{}).Create(resIds)
	return &model.UpdateUserPayload{
		Count: int(d.RowsAffected),
	}, d.Error
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input []*model.UserInput) (*model.AddUserPayload, error) {
	v, okHook := r.Sql.Hooks["AddUser"].(db.GqlGenSqlHookAdd[model.User, model.UserInput, model.AddUserPayload])
	res := &model.AddUserPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.User, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	v, okHook := r.Sql.Hooks["UpdateUser"].(db.GqlGenSqlHookUpdate[model.User, model.UpdateUserInput, model.UpdateUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName), "AND")
	obj := model.User{}
	db = db.Model(&obj).Where(sql, arguments...)
	u := input.Set.MergeToType()
	update := &u
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(*update)
	res := &model.UpdateUserPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, filter model.UserFiltersInput) (*model.DeleteUserPayload, error) {
	v, okHook := r.Sql.Hooks["DeleteUser"].(db.GqlGenSqlHookDelete[model.User, model.UserFiltersInput, model.DeleteUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName), "AND")
	obj := model.User{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUserPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}
