// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"

	"github.com/fasibio/gqlgensql/graph/model"
	"github.com/fasibio/gqlgensql/plugin/gqlgensql/runtimehelper"
	"gorm.io/gorm/clause"
)

// GetCompany is the resolver for the getCompany field.

func (r *queryResolver) GetCompany(ctx context.Context, id int) (*model.Company, error) {
	var res model.Company
	d := runtimehelper.GetPreloadSelection(ctx, r.Sql.Db, runtimehelper.GetPreloadsMap(ctx)).First(&res, id)
	return &res, d.Error
}

// QueryCompany is the resolver for the queryCompany field.
func (r *queryResolver) QueryCompany(ctx context.Context, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int) (*model.CompanyQueryResult, error) {
	var res []*model.Company
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	db := runtimehelper.GetPreloadSelection(ctx, r.Sql.Db, runtimehelper.GetPreloadsMap(ctx).SubTables[0])
	db.Statement.AddClause(clause.Where{Exprs: filter.ExtendsDatabaseQuery(db, tableName)})
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	d := db.Find(&res)
	return &model.CompanyQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, d.Error
}

// AddCompany is the resolver for the addCompany field.
func (r *mutationResolver) AddCompany(ctx context.Context, input []*model.CompanyInput) (*model.AddCompanyPayload, error) {
	obj := make([]model.Company, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	res := r.Sql.Db.Omit(clause.Associations).Create(&obj)
	return &model.AddCompanyPayload{}, res.Error
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.UpdateCompanyPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateCompany - updateCompany"))
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, filter model.CompanyFiltersInput) (*model.DeleteCompanyPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteCompany - deleteCompany"))
}

// GetUser is the resolver for the getUser field.

func (r *queryResolver) GetUser(ctx context.Context, id int) (*model.User, error) {
	var res model.User
	d := runtimehelper.GetPreloadSelection(ctx, r.Sql.Db, runtimehelper.GetPreloadsMap(ctx)).First(&res, id)
	return &res, d.Error
}

// QueryUser is the resolver for the queryUser field.
func (r *queryResolver) QueryUser(ctx context.Context, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	var res []*model.User
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	db := runtimehelper.GetPreloadSelection(ctx, r.Sql.Db, runtimehelper.GetPreloadsMap(ctx).SubTables[0])
	db.Statement.AddClause(clause.Where{Exprs: filter.ExtendsDatabaseQuery(db, tableName)})
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	d := db.Find(&res)
	return &model.UserQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, d.Error
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input []*model.UserInput) (*model.AddUserPayload, error) {
	obj := make([]model.User, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	res := r.Sql.Db.Omit(clause.Associations).Create(&obj)
	return &model.AddUserPayload{}, res.Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, filter model.UserFiltersInput) (*model.DeleteUserPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}
