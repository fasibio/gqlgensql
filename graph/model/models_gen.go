// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddCompanyPayload struct {
	Company *CompanyQueryResult `json:"company"`
}

type AddTodoPayload struct {
	Todo *TodoQueryResult `json:"todo"`
}

type AddUserPayload struct {
	User *UserQueryResult `json:"user"`
}

type BooleanFilterInput struct {
	And     []*bool             `json:"and"`
	Or      []*bool             `json:"or"`
	Not     *BooleanFilterInput `json:"not"`
	Is      *bool               `json:"is"`
	Null    *bool               `json:"null"`
	NotNull *bool               `json:"notNull"`
}

type CompanyFiltersInput struct {
	ID              *IntFilterInput        `json:"id"`
	Name            *StringFilterInput     `json:"Name"`
	MotherCompanyID *IntFilterInput        `json:"motherCompanyID"`
	MotherCompany   *CompanyFiltersInput   `json:"motherCompany"`
	And             []*CompanyFiltersInput `json:"and"`
	Or              []*CompanyFiltersInput `json:"or"`
	Not             *CompanyFiltersInput   `json:"not"`
}

type CompanyInput struct {
	ID              int           `json:"id"`
	Name            string        `json:"Name"`
	MotherCompanyID *int          `json:"motherCompanyID"`
	MotherCompany   *CompanyInput `json:"motherCompany"`
}

type CompanyOrder struct {
	Asc  *CompanyOrderable `json:"asc"`
	Desc *CompanyOrderable `json:"desc"`
}

type CompanyPatch struct {
	ID              *int          `json:"id"`
	Name            *string       `json:"Name"`
	MotherCompanyID *int          `json:"motherCompanyID"`
	MotherCompany   *CompanyPatch `json:"motherCompany"`
}

type CompanyQueryResult struct {
	Data       []*Company `json:"data"`
	Count      int        `json:"count"`
	TotalCount int        `json:"totalCount"`
}

type CompanyWhere struct {
	ID              *int    `json:"id"`
	Name            *string `json:"Name"`
	MotherCompanyID *int    `json:"motherCompanyID"`
}

type DeleteCompanyPayload struct {
	Company *CompanyQueryResult `json:"company"`
	Count   int                 `json:"count"`
	Msg     *string             `json:"msg"`
}

type DeleteTodoPayload struct {
	Todo  *TodoQueryResult `json:"todo"`
	Count int              `json:"count"`
	Msg   *string          `json:"msg"`
}

type DeleteUserPayload struct {
	User  *UserQueryResult `json:"user"`
	Count int              `json:"count"`
	Msg   *string          `json:"msg"`
}

type IDFilterInput struct {
	And     []*string      `json:"and"`
	Or      []*string      `json:"or"`
	Not     *IDFilterInput `json:"not"`
	Eq      *string        `json:"eq"`
	Ne      *string        `json:"ne"`
	Null    *bool          `json:"null"`
	NotNull *bool          `json:"notNull"`
	In      []*string      `json:"in"`
	Notin   []*string      `json:"notin"`
}

type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

type IntFilterInput struct {
	And     []*int            `json:"and"`
	Or      []*int            `json:"or"`
	Not     *IntFilterInput   `json:"not"`
	Eq      *int              `json:"eq"`
	Ne      *int              `json:"ne"`
	Gt      *int              `json:"gt"`
	Gte     *int              `json:"gte"`
	Lt      *int              `json:"lt"`
	Lte     *int              `json:"lte"`
	Null    *bool             `json:"null"`
	NotNull *bool             `json:"notNull"`
	In      []*int            `json:"in"`
	NotIn   []*int            `json:"notIn"`
	Between *IntFilterBetween `json:"between"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add"`
	Update       *SQLCreateExtension `json:"update"`
	Delete       *SQLCreateExtension `json:"delete"`
	DirectiveExt []string            `json:"directiveExt"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get"`
	Query        *SQLCreateExtension `json:"query"`
	DirectiveExt []string            `json:"directiveExt"`
}

type StringFilterInput struct {
	And          []*string          `json:"and"`
	Or           []*string          `json:"or"`
	Not          *StringFilterInput `json:"not"`
	Eq           *string            `json:"eq"`
	Eqi          *string            `json:"eqi"`
	Ne           *string            `json:"ne"`
	StartsWith   *string            `json:"startsWith"`
	EndsWith     *string            `json:"endsWith"`
	Contains     *string            `json:"contains"`
	NotContains  *string            `json:"notContains"`
	Containsi    *string            `json:"containsi"`
	NotContainsi *string            `json:"notContainsi"`
	Null         *bool              `json:"null"`
	NotNull      *bool              `json:"notNull"`
	In           []*string          `json:"in"`
	NotIn        []*string          `json:"notIn"`
}

type Todo struct {
	ID          int     `json:"id" gorm:"primaryKey"`
	Title       string  `json:"title"`
	Description string  `json:"description"`
	Done        bool    `json:"done"`
	Users       []*User `json:"users" gorm:"many2many:user_todos"`
}

type TodoFiltersInput struct {
	ID          *IntFilterInput     `json:"id"`
	Title       *StringFilterInput  `json:"title"`
	Description *StringFilterInput  `json:"description"`
	Done        *BooleanFilterInput `json:"done"`
	Users       *UserFiltersInput   `json:"users"`
	And         []*TodoFiltersInput `json:"and"`
	Or          []*TodoFiltersInput `json:"or"`
	Not         *TodoFiltersInput   `json:"not"`
}

type TodoInput struct {
	ID          int          `json:"id"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Done        bool         `json:"done"`
	Users       []*UserInput `json:"users"`
}

type TodoOrder struct {
	Asc  *TodoOrderable `json:"asc"`
	Desc *TodoOrderable `json:"desc"`
}

type TodoPatch struct {
	ID          *int         `json:"id"`
	Title       *string      `json:"title"`
	Description *string      `json:"description"`
	Done        *bool        `json:"done"`
	Users       []*UserPatch `json:"users"`
}

type TodoQueryResult struct {
	Data       []*Todo `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

type TodoRef2UsersInput struct {
	Filter *UserFiltersInput `json:"filter"`
	Set    []int             `json:"set"`
}

type TodoWhere struct {
	ID          *int    `json:"id"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Done        *bool   `json:"done"`
}

type UpdateCompanyInput struct {
	Filter *CompanyFiltersInput `json:"filter"`
	Set    *CompanyPatch        `json:"set"`
}

type UpdateCompanyPayload struct {
	Company *CompanyQueryResult `json:"company"`
	Count   int                 `json:"count"`
}

type UpdateTodoInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    *TodoPatch        `json:"set"`
}

type UpdateTodoPayload struct {
	Todo  *TodoQueryResult `json:"todo"`
	Count int              `json:"count"`
}

type UpdateUserInput struct {
	Filter *UserFiltersInput `json:"filter"`
	Set    *UserPatch        `json:"set"`
}

type UpdateUserPayload struct {
	User  *UserQueryResult `json:"user"`
	Count int              `json:"count"`
}

type User struct {
	ID        int      `json:"id" gorm:"primaryKey"`
	Name      string   `json:"name"`
	CompanyID *int     `json:"companyID"`
	Company   *Company `json:"company"`
	TodoList  []*Todo  `json:"todoList" gorm:"many2many:user_todos"`
}

type UserFiltersInput struct {
	ID        *IntFilterInput      `json:"id"`
	Name      *StringFilterInput   `json:"name"`
	CompanyID *IntFilterInput      `json:"companyID"`
	Company   *CompanyFiltersInput `json:"company"`
	TodoList  *TodoFiltersInput    `json:"todoList"`
	And       []*UserFiltersInput  `json:"and"`
	Or        []*UserFiltersInput  `json:"or"`
	Not       *UserFiltersInput    `json:"not"`
}

type UserInput struct {
	ID        int           `json:"id"`
	Name      string        `json:"name"`
	CompanyID *int          `json:"companyID"`
	Company   *CompanyInput `json:"company"`
	TodoList  []*TodoInput  `json:"todoList"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc"`
	Desc *UserOrderable `json:"desc"`
}

type UserPatch struct {
	ID        *int          `json:"id"`
	Name      *string       `json:"name"`
	CompanyID *int          `json:"companyID"`
	Company   *CompanyPatch `json:"company"`
	TodoList  []*TodoPatch  `json:"todoList"`
}

type UserQueryResult struct {
	Data       []*User `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

type UserRef2TodosInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    []int             `json:"set"`
}

type UserWhere struct {
	ID        *int    `json:"id"`
	Name      *string `json:"name"`
	CompanyID *int    `json:"companyID"`
}

type CompanyOrderable string

const (
	CompanyOrderableID              CompanyOrderable = "id"
	CompanyOrderableName            CompanyOrderable = "Name"
	CompanyOrderableMotherCompanyID CompanyOrderable = "motherCompanyID"
)

var AllCompanyOrderable = []CompanyOrderable{
	CompanyOrderableID,
	CompanyOrderableName,
	CompanyOrderableMotherCompanyID,
}

func (e CompanyOrderable) IsValid() bool {
	switch e {
	case CompanyOrderableID, CompanyOrderableName, CompanyOrderableMotherCompanyID:
		return true
	}
	return false
}

func (e CompanyOrderable) String() string {
	return string(e)
}

func (e *CompanyOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompanyOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompanyOrderable", str)
	}
	return nil
}

func (e CompanyOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TodoOrderable string

const (
	TodoOrderableID          TodoOrderable = "id"
	TodoOrderableTitle       TodoOrderable = "title"
	TodoOrderableDescription TodoOrderable = "description"
	TodoOrderableDone        TodoOrderable = "done"
)

var AllTodoOrderable = []TodoOrderable{
	TodoOrderableID,
	TodoOrderableTitle,
	TodoOrderableDescription,
	TodoOrderableDone,
}

func (e TodoOrderable) IsValid() bool {
	switch e {
	case TodoOrderableID, TodoOrderableTitle, TodoOrderableDescription, TodoOrderableDone:
		return true
	}
	return false
}

func (e TodoOrderable) String() string {
	return string(e)
}

func (e *TodoOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TodoOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TodoOrderable", str)
	}
	return nil
}

func (e TodoOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableID        UserOrderable = "id"
	UserOrderableName      UserOrderable = "name"
	UserOrderableCompanyID UserOrderable = "companyID"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableID,
	UserOrderableName,
	UserOrderableCompanyID,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableID, UserOrderableName, UserOrderableCompanyID:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
