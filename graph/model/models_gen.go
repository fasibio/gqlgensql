// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddCompanyPayload struct {
	Company []*Company `json:"company"`
}

type AddUserPayload struct {
	User []*User `json:"user"`
}

type BooleanFilterInput struct {
	And     []*bool             `json:"and"`
	Or      []*bool             `json:"or"`
	Not     *BooleanFilterInput `json:"not"`
	Is      *bool               `json:"is"`
	Null    *bool               `json:"null"`
	NotNull *bool               `json:"notNull"`
}

type CompanyFiltersInput struct {
	ID              *IntFilterInput        `json:"id"`
	Name            *StringFilterInput     `json:"Name"`
	MotherCompanyID *IntFilterInput        `json:"motherCompanyID"`
	MotherCompany   *CompanyFiltersInput   `json:"motherCompany"`
	And             []*CompanyFiltersInput `json:"and"`
	Or              []*CompanyFiltersInput `json:"or"`
	Not             *CompanyFiltersInput   `json:"not"`
}

type CompanyInput struct {
	ID              int           `json:"id"`
	Name            string        `json:"Name"`
	MotherCompanyID *int          `json:"motherCompanyID"`
	MotherCompany   *CompanyInput `json:"motherCompany"`
}

type CompanyOrder struct {
	Asc  *CompanyOrderable `json:"asc"`
	Desc *CompanyOrderable `json:"desc"`
}

type CompanyPatch struct {
	ID              *int          `json:"id"`
	Name            *string       `json:"Name"`
	MotherCompanyID *int          `json:"motherCompanyID"`
	MotherCompany   *CompanyPatch `json:"motherCompany"`
}

type CompanyQueryResult struct {
	Data       []*Company `json:"data"`
	Count      int        `json:"count"`
	TotalCount int        `json:"totalCount"`
}

type CompanyWhere struct {
	ID              *int    `json:"id"`
	Name            *string `json:"Name"`
	MotherCompanyID *int    `json:"motherCompanyID"`
}

type DeleteCompanyPayload struct {
	Company []*Company `json:"company"`
	Count   int        `json:"count"`
	Msg     *string    `json:"msg"`
}

type DeleteUserPayload struct {
	User  []*User `json:"user"`
	Count int     `json:"count"`
	Msg   *string `json:"msg"`
}

type IDFilterInput struct {
	And     []*string      `json:"and"`
	Or      []*string      `json:"or"`
	Not     *IDFilterInput `json:"not"`
	Eq      *string        `json:"eq"`
	Ne      *string        `json:"ne"`
	Null    *bool          `json:"null"`
	NotNull *bool          `json:"notNull"`
	In      []*string      `json:"in"`
	Notin   []*string      `json:"notin"`
}

type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

type IntFilterInput struct {
	And     []*int            `json:"and"`
	Or      []*int            `json:"or"`
	Not     *IntFilterInput   `json:"not"`
	Eq      *int              `json:"eq"`
	Ne      *int              `json:"ne"`
	Gt      *int              `json:"gt"`
	Gte     *int              `json:"gte"`
	Lt      *int              `json:"lt"`
	Lte     *int              `json:"lte"`
	Null    *bool             `json:"null"`
	NotNull *bool             `json:"notNull"`
	In      []*int            `json:"in"`
	NotIn   []*int            `json:"notIn"`
	Between *IntFilterBetween `json:"between"`
}

type SQLMutationParams struct {
	Add          *bool    `json:"add"`
	Update       *bool    `json:"update"`
	Delete       *bool    `json:"delete"`
	DirectiveEtx []string `json:"directiveEtx"`
}

type SQLQueryParams struct {
	Get          *bool    `json:"get"`
	Query        *bool    `json:"query"`
	DirectiveEtx []string `json:"directiveEtx"`
}

type StringFilterInput struct {
	And          []*string          `json:"and"`
	Or           []*string          `json:"or"`
	Not          *StringFilterInput `json:"not"`
	Eq           *string            `json:"eq"`
	Eqi          *string            `json:"eqi"`
	Ne           *string            `json:"ne"`
	StartsWith   *string            `json:"startsWith"`
	EndsWith     *string            `json:"endsWith"`
	Contains     *string            `json:"contains"`
	NotContains  *string            `json:"notContains"`
	Containsi    *string            `json:"containsi"`
	NotContainsi *string            `json:"notContainsi"`
	Null         *bool              `json:"null"`
	NotNull      *bool              `json:"notNull"`
	In           []*string          `json:"in"`
	NotIn        []*string          `json:"notIn"`
}

type UpdateCompanyInput struct {
	Filter *CompanyFiltersInput `json:"filter"`
	Set    *CompanyPatch        `json:"set"`
	Remove *CompanyPatch        `json:"remove"`
}

type UpdateCompanyPayload struct {
	Company []*Company `json:"company"`
	Count   int        `json:"count"`
}

type UpdateUserInput struct {
	Filter *UserFiltersInput `json:"filter"`
	Set    *UserPatch        `json:"set"`
	Remove *UserPatch        `json:"remove"`
}

type UpdateUserPayload struct {
	User  []*User `json:"user"`
	Count int     `json:"count"`
}

type User struct {
	ID        int      `json:"id" gorm:"primaryKey"`
	Name      string   `json:"name"`
	CompanyID *int     `json:"companyID"`
	Company   *Company `json:"company"`
}

type UserFiltersInput struct {
	ID        *IntFilterInput      `json:"id"`
	Name      *StringFilterInput   `json:"name"`
	CompanyID *IntFilterInput      `json:"companyID"`
	Company   *CompanyFiltersInput `json:"company"`
	And       []*UserFiltersInput  `json:"and"`
	Or        []*UserFiltersInput  `json:"or"`
	Not       *UserFiltersInput    `json:"not"`
}

type UserInput struct {
	ID        int           `json:"id"`
	Name      string        `json:"name"`
	CompanyID *int          `json:"companyID"`
	Company   *CompanyInput `json:"company"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc"`
	Desc *UserOrderable `json:"desc"`
}

type UserPatch struct {
	ID        *int          `json:"id"`
	Name      *string       `json:"name"`
	CompanyID *int          `json:"companyID"`
	Company   *CompanyPatch `json:"company"`
}

type UserQueryResult struct {
	Data       []*User `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

type UserWhere struct {
	ID        *int    `json:"id"`
	Name      *string `json:"name"`
	CompanyID *int    `json:"companyID"`
}

type CompanyOrderable string

const (
	CompanyOrderableID              CompanyOrderable = "id"
	CompanyOrderableName            CompanyOrderable = "Name"
	CompanyOrderableMotherCompanyID CompanyOrderable = "motherCompanyID"
)

var AllCompanyOrderable = []CompanyOrderable{
	CompanyOrderableID,
	CompanyOrderableName,
	CompanyOrderableMotherCompanyID,
}

func (e CompanyOrderable) IsValid() bool {
	switch e {
	case CompanyOrderableID, CompanyOrderableName, CompanyOrderableMotherCompanyID:
		return true
	}
	return false
}

func (e CompanyOrderable) String() string {
	return string(e)
}

func (e *CompanyOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompanyOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompanyOrderable", str)
	}
	return nil
}

func (e CompanyOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableID        UserOrderable = "id"
	UserOrderableName      UserOrderable = "name"
	UserOrderableCompanyID UserOrderable = "companyID"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableID,
	UserOrderableName,
	UserOrderableCompanyID,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableID, UserOrderableName, UserOrderableCompanyID:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
